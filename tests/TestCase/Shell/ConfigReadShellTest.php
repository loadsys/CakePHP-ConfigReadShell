<?php
/**
 * Tests for the ConfigReadShell class.
 */
namespace ConfigRead\Test\TestCase\Shell;

use Cake\Console\ConsoleOptionParser;
use Cake\Console\Shell;
use Cake\Core\Configure;
use Cake\TestSuite\TestCase;
use ConfigRead\Shell\ConfigReadShell;

/**
 * TestConfigReadShell class
 *
 * Exposes protected methods for direct testing.
 */
class TestConfigReadShell extends ConfigReadShell {
	public function simpleFetchAndPrint() {
		return parent::simpleFetchAndPrint();
	}

	public function serializedFetchAndPrint() {
		return parent::serializedFetchAndPrint();
	}

	public function fetchVal($key) {
		return parent::fetchVal($key);
	}

	public function iterateOnKey($key, $val) {
		return parent::iterateOnKey($key, $val);
	}

	public function printVal($key, $val) {
		return parent::printVal($key, $val);
	}
}

/**
 * ConfigReadShellTest class
 *
 */
class ConfigReadShellTest extends TestCase {

	/**
	 * Fixtures used in this test case
	 *
	 * @var array
	 */
	public $fixtures = [
	];

	/**
	 * Acts as an accumulator for output produced by the Shell.
	 *
	 * @var array
	 * @see ::initSUIT()
	 */
	public $output = [
	];

	/**
	 * setUp method
	 *
	 * @return void
	 */
	public function setUp() {
		parent::setUp();

		$this->output = [];
		$this->Shell = $this->initSUT();
	}

	/**
	 * tearDown method
	 *
	 * @return void
	 */
	public function tearDown() {
		unset($this->io, $this->Shell);
		$this->output = [];

		parent::tearDown();
	}

	/**
	 * Helper for accumulating I/O output generated by the Shell.
	 *
	 * @param string $s The output string being printed.
	 * @see ::initSUT()
	 */
	public function outputCollector($s, $newlines = 1, $level = Shell::NORMAL) {
		$this->output[] = $s;
	}

	/**
	 * Helper for determing the subject class to initialize for testing.
	 *
	 * Methodology:
	 *   - Take the name of this testing class: `SomeObjectTest`
	 *   - If there exists a `TestSomeObject` class (presumed to extend
	 *     SomeObject to expose private/protected methods for testing)
	 *     then return that.
	 *   - Otherwise, guess the namespace of the subject class by
	 *     removing `*\Test\TestCase\*\*Test` from this testing classes
	 *     name and use that.
	 *   - As a side-effect, set a local class property with the
	 *     non-namespaced `SomeObject` name for future reference in tests.
	 *
	 * @return string The fully-namespaced class name to instantiate.
	 * @see ::initSUT()
	 */
	protected function getSUTClassName() {
		$testCaseClass = '\\' . get_class($this);
			// -> ConfigRead\Test\TestCase\Shell\ConfigReadShellTest

		$testingOverrideClass = preg_replace(
			'/^(.*)\\\([^\\\]+)Test$/',
			'\1\\\Test\2',
			$testCaseClass
		); // -> ConfigRead\Test\TestCase\Shell\TestConfigReadShell

		$testedClass = preg_replace(
			'/^(.*)\\\Test\\\TestCase\\\(.*)Test$/',
			'\1\\\\\2',
			$testCaseClass
		); // -> ConfigRead\Shell\ConfigReadShell

		$this->classBasename = preg_replace(
			'/^.*\\\([^\\\]+)$/',
			'\1',
			$testedClass
		); // -> ConfigReadShell

		return (class_exists($testingOverrideClass) ? $testingOverrideClass : $testedClass);
	}

	/**
	 * Helper for setting up an instance of the target Shell with proper
	 * mocked methods.
	 *
	 * The Shell that will be mocked is taken from the test class name
	 * automatically. Example: `SomeShellTest extends CakeTestCase` will
	 * create a mocked copy of `SomeShell`. Will check for a subclassed
	 * `TestSomeShell` and instantiate that instead, if available, to
	 * allow for overriding protected methods.
	 *
	 * All of the fixtures defined in the test class will be "installed"
	 * into the mocked Shell.
	 *
	 * Typically called in ::setUp() or at the beginning
	 * of a test method (if additional mocked methods are necessary.)
	 *
	 * @return mixed A partially mocked copy of the Shell matching the test class's name.
	 */
	protected function initSUT($additionalMocks = []) {
		$defaultMocks = [
			'help', //'in', 'out', 'hr', 'error', 'err', '_stop', 'initialize', '_run', 'clear',
		];

		$this->io = $this->getMock('\Cake\Console\ConsoleIo', [], [], '', false);
		$this->io->expects($this->any())
			->method('out')
			->with($this->anything())
			->will($this->returnCallback([$this, 'outputCollector']));


		$class = $this->getSUTClassName();
		$mockedMethods = array_merge($defaultMocks, $additionalMocks);
		$shell = $this->getMock(
			$class,
			$mockedMethods,
			[$this->io]
		);

		$shell->OptionParser = $this->getMock('\Cake\Console\ConsoleOptionParser', [], [null, false]);

		//@TODO: Update this Cake2-centric code to load models in a Cake 3 Shell.
		// Load and attach all fixtures defined in this test case.
// 		foreach ($this->fixtures as $fixture) {
// 			$modelName = str_replace('App.', '', implode('.', array_map('Inflector::classify', explode('.', $fixture))));
// 			$propName = str_replace('.', '', $modelName);
// 			$shell->{$propName} = ClassRegistry::init($modelName);
// 		}
		return $shell;
	}

	/**
	 * Confirm that startup() engages help output when flag is present.
	 *
	 * @return void
	 */
	public function testStartupHelp() {
		$this->Shell->params = ['h' => true];
		$this->Shell->expects($this->once())
			->method('help')
			->will($this->returnValue('canary'));
		$this->assertEquals(
			'canary',
			$this->Shell->startup(),
			'Shell should return help() when -h is passed.'
		);
	}

	/**
	 * Confirm that startup() engages bash output mode when -b flag is present.
	 *
	 * @return void
	 */
	public function testStartupBashModeFlag() {
		$this->Shell->params = ['b' => 'canary'];

		$this->Shell->startup();
		
		$this->assertEquals(
			['canary'],
			$this->Shell->args,
			'Shell args should contain the value mistakenly captured by the -b option.'
		);
		$this->assertTrue(
			$this->Shell->formatBash,
			'Bash output formatting should be enabled by the presence of the -b option.'
		);
	}

	/**
	 * Confirm that startup() engages bash output mode when multiple args are present.
	 *
	 * @return void
	 */
	public function testStartupBashModeMultiArgs() {
		$this->Shell->args = ['debug', 'Datasources.default.host'];

		$this->Shell->startup();
		
		$this->assertTrue(
			$this->Shell->formatBash,
			'Bash output formatting should be enabled by the presence of multiple arguments.'
		);
	}

	/**
	 * Confirm that startup() engages serialized output mode when -s flag is present.
	 *
	 * @return void
	 */
	public function testStartupSerializeModeFlag() {
		$this->Shell->params = ['s' => 'canary'];

		$this->Shell->startup();
		
		$this->assertEquals(
			['canary'],
			$this->Shell->args,
			'Shell args should contain the value mistakenly captured by the -s option.'
		);
		$this->assertTrue(
			$this->Shell->formatSerialize,
			'Serialized output formatting should be enabled by the presence of the -s option.'
		);
	}

	/**
	 * test main() using simple (bash) output.
	 *
	 * @return void
	 */
	public function testMainSimple() {
		$expected = [
			'key' => 'val',
			'debug' => true,
			'ary' => [
				'foo' => 'bar',
				'fizz' => 'buzz',
			],
		];

		$shell = $this->initSUT(['fetchVal', 'iterateOnKey']);
		$shell->args = array_keys($expected);

		$i = 0;
		foreach ($expected as $k => $v) {
			$shell->expects($this->at($i++))
				->method('fetchVal')
				->with($k)
				->will($this->returnValue($v));
			$shell->expects($this->at($i++))
				->method('iterateOnKey')
				->with($k, $v);
		}

		// Can't use runCommand() because it requires a host Cake app.
		//$shell->runCommand(array_keys($expected));
		// So simulate startup and execution directly:
		$shell->startup();
		$shell->main();

		$this->assertTrue(
			$shell->formatBash,
			'Bash output should be engaged automatically by presence of multiple command line args.'
		);
	}

	/**
	 * test main(), including associated protected methods, using simple output.
	 *
	 * @return void
	 */
	public function testMainSimpleIntegration() {
		$configure = [
			'key' => 'val',
			'debug' => true,
			'ary' => [
				'foo' => 'bar',
				'fizz' => 'buzz',
			],
		];
		$expected = [
			"KEY='val'",
			"DEBUG='1'",
			"ARY_FOO='bar'",
			"ARY_FIZZ='buzz'",
		];
		Configure::write($configure);
		$this->Shell->args = array_keys($configure);

		$this->Shell->startup();
		$this->Shell->main();

		$this->assertEquals(
			$expected,
			$this->output,
			'The output produced from running the shell on the given arguments should match our expected result.'
		);
		$this->assertTrue(
			$this->Shell->formatBash,
			'Bash output should be engaged automatically by presence of multiple command line args.'
		);
	}

	/**
	 * test main(), including associated protected methods, using simple output.
	 *
	 * @param array $params Array of params to seed the Shell->params with.
	 * @param array $args Array of arguments to seed the Shell->args with.
	 * @param array $expected Array of generated output lines to compare to ::$output.
	 * @param string $msg Optional PHPUnit assertion failure message.
	 * @return void
	 * @dataProvider provideSerializedArgs
	 */
	public function testMainSerializedIntegration($params, $args, $expected, $msg = '') {
		$configure = [
			'key' => 'val',
			'debug' => true,
			'ary' => [
				'one' => 1,
				'two' => '2',
				3 => 'three',
				'stdClass' => (new \StdClass()),
			],
		];

		Configure::write($configure);
		$this->Shell->params = $params;
		$this->Shell->args = $args;

		$this->Shell->startup();
		$this->Shell->main();

		$this->assertEquals(
			$expected,
			$this->output,
			$msg
		);
		$this->assertTrue(
			$this->Shell->formatSerialize,
			'Serialized output should be engaged from the provided param.'
		);
	}

	/**
	 * Provides input arguments to testMainSerializedIntegration().
	 *
	 * All keys named in the [params] and [args] elements must exist in
	 * $configure as defined in testMainSerializedIntegration() above.
	 *
	 * @return void
	 * @dataProvider provideSerializedArgs
	 */
	public function provideSerializedArgs() {
		return [
			[
				['s' => ''], // Params to load in the Shell.
				[], // Args to load in the Shell.
				['N;'], // Expected lines of output.
				'Empty input should produce a serialized `null` string.', // PHPUnit assertion failure message.
			],

			[
				['s' => 'key'],
				[],
				['s:3:"val";'],
				'Single scalar value should be serialized directly.',
			],

			[
				['s' => 'key'],
				['ary.stdClass'],
				['a:2:{s:3:"key";s:3:"val";s:12:"ary.stdClass";O:8:"stdClass":0:{}}'],
				'Multiple requested keys should be combined into a (serialized) associative array.',
			],
		];
	}
}
